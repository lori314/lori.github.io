---
title: ROS1中的动作程序编写
author: Magic魔小牛
date: 2025-09-20 12:00:00 +0800
categories: [Blogging, Tutorial]
tags: [ROS]
render_with_liquid: false
---

（注意：本站所有博客均是记录本人学习过程中的理解，可能存在错误和不完善之处，请仔细甄别）

## ROS中的动作

上一章我们讲了服务，设想一下真实的机器人应用场景——比如让机器人从场地的左边走到右边。首先，我们只在需要走的时候走过去，用话题不太合适；走过去的流程很长，如果要用服务，如果把服务内容设定为机器人走一步，那么就要反复调用很多次；如果设置为走到底，那么我很长一段时间都不能再控制它了——没有好的中止机制。而且最重要的是，我们没有好的反馈机制来掌握机器人的位置信息，或者说任务进度如何。为了解决这种长时间，需要反馈的任务，我们引入了动作，用它来构建负责这类任务的节点有着很好的效果。

动作和服务一样，也是由两大主体构成的：服务端（client）和客户端（server）。调用方式也类似，只是程序的书写形式不同。为了更好的讲解，我们还是引入一个具体的任务：我们需要启动一个节点，它可以让我们的小海龟原地转3圈，并且每转一圈就要报告一下一共转了多少圈。为此我们需要设计动作服务端和动作客户端，并通过具体的代码来讲解一般书写方法。

## ROS动作程序编写

类似的，在动作程序编写之前，我们需要先定义服务端的接收数据类型、响应数据类型。如下（TurtleSpin.action）所示：

```action
int32 num_rotations
---
int32 rotations_completed
---
int32 rotations_completed
```

我们发现这里有三组字段。我们一一解析：最上面的表示接受数据类型，需要一个int32类型的数据，命名为num_rotations；中间的表示响应数据类型，也需要一个int32类型的数据，命名为rotations_completed；最下面的表示反馈数据类型，是int32类型，它要的和我们的响应数据类型是一样的，在这个例子中是合理的。因为我们要的是转了几圈，那么结束的标志就是转了3圈，用rotations_completed就足够反映。

将上述文件保存在**与src同级**的action目录下后，我们来看服务端的代码`turtle_spin_server.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import rospy
import actionlib
import math
from geometry_msgs.msg import Twist
from beginner_tutorials.msg import TurtleSpinAction, TurtleSpinFeedback, TurtleSpinResult

class TurtleSpinActionServer:
    def __init__(self):
        # 创建一个发布者，用于向turtlesim发送速度指令
        self._turtle_pub = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=1)
        
        # 创建动作服务端
        self._as = actionlib.SimpleActionServer('turtle_spin', TurtleSpinAction, execute_cb=self.execute_cb, auto_start=False)
        self._as.start()
        rospy.loginfo("海龟旋转动作服务端已准备就绪。")

    def execute_cb(self, goal):
        rospy.loginfo("收到目标: 旋转 %d 圈" % goal.num_rotations)
        
        # 设置旋转速度 (弧度/秒)
        angular_speed = 1.0  # 约6.28秒转一圈
        
        # 准备反馈和结果的消息对象
        feedback = TurtleSpinFeedback()
        result = TurtleSpinResult()
        
        # --- 旋转任务的主循环 ---
        for i in range(goal.num_rotations):
            rospy.loginfo("开始旋转第 %d 圈..." % (i + 1))
            
            # 检查客户端是否中途取消了任务
            if self._as.is_preempt_requested():
                rospy.loginfo("任务被客户端取消。")
                self._as.set_preempted()
                return

            # --- 控制海龟精确旋转一圈 ---
            t0 = rospy.Time.now().to_sec()
            current_angle = 0
            
            # 创建Twist消息
            twist = Twist()
            twist.angular.z = angular_speed

            # 循环发布速度指令，直到转满2π弧度
            while current_angle < 2 * math.pi:
                self._turtle_pub.publish(twist)
                t1 = rospy.Time.now().to_sec()
                current_angle = angular_speed * (t1 - t0)
                rospy.sleep(0.01)
            
            # 转完一圈后，停止海龟
            self._turtle_pub.publish(Twist())

            # --- 发布反馈 ---
            feedback.rotations_completed = i + 1
            self._as.publish_feedback(feedback)
            rospy.loginfo("已完成 %d 圈。" % feedback.rotations_completed)

        # 任务成功完成
        result.rotations_completed = goal.num_rotations
        rospy.loginfo("任务成功完成！总共旋转了 %d 圈。" % result.rotations_completed)
        self._as.set_succeeded(result)

if __name__ == '__main__':
    rospy.init_node('turtle_spin_server_node')
    server = TurtleSpinActionServer()
    rospy.spin()
```

- 导入：我们写动作节点，需要有`import actionlib`这一步。像服务一样，我们也需要从.action文件生成的类：`from beginner_tutorials.msg import TurtleSpinAction, TurtleSpinFeedback, TurtleSpinResult`。它们的产生规则分别是文件名+Action，文件名+Feedback，文件名+Result。其含义即英文释义。
